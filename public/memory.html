<!DOCTYPE html>
<html lang="zh-TW" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>記憶系統 - Thewavess AI Core</title>
    
    <!-- Tailwind CSS 3.4.17 -->
    <script src="https://cdn.tailwindcss.com/3.4.17"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <!-- Moment.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.30.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.30.1/locale/zh-tw.min.js"></script>
    
</head>
<body class="min-h-full p-4 bg-gray-50 text-gray-900">
    <!-- 頂部導航 -->
    <nav class="bg-white border rounded-lg p-4 mb-4">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-4">
                <button 
                    class="bg-gray-600 hover:bg-gray-700 text-white p-2 rounded"
                    onclick="goBack()"
                >
                    <i class="fas fa-arrow-left"></i>
                </button>
                
                <h1 class="text-2xl font-bold">
                    <i class="fas fa-brain text-purple-400 mr-2"></i>
                    記憶系統
                </h1>
            </div>
            
            <div class="flex items-center space-x-2">
                <button 
                    class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded"
                    onclick="backupMemory()"
                >
                    <i class="fas fa-cloud-upload mr-2"></i>
                    備份記憶
                </button>
                
                <button 
                    class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded"
                    onclick="refreshMemoryData()"
                >
                    <i class="fas fa-sync mr-2"></i>
                    刷新
                </button>
            </div>
        </div>
    </nav>
    
    <!-- 主內容區域 -->
    <div class="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-4 gap-6">
        <!-- 左側 - 記憶時間軸 -->
        <div class="lg:col-span-3 space-y-6">
            <!-- 記憶搜尋 -->
            <div class="bg-white border rounded-lg p-6">
                <h2 class="text-xl font-semibold mb-4">
                    <i class="fas fa-search text-blue-400 mr-2"></i>
                    記憶搜尋
                </h2>
                
                <div class="flex space-x-4 mb-4">
                    <div class="flex-1">
                        <input 
                            type="text" 
                            id="memorySearchQuery"
                            class="w-full px-4 py-3 rounded bg-gray-100 border text-gray-900 focus:ring-2 focus:ring-blue-500"
                            placeholder="搜尋記憶內容、偏好、里程碑..."
                            onkeypress="handleMemorySearchKeyPress(event)"
                        >
                    </div>
                    <button 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded"
                        onclick="searchMemory()"
                    >
                        <i class="fas fa-search mr-2"></i>
                        搜尋
                    </button>
                </div>
                
                <!-- 記憶類型篩選 -->
                <div class="flex flex-wrap gap-2">
                    <button class="memory-filter-btn active" data-type="all">全部</button>
                    <button class="memory-filter-btn" data-type="preference">偏好</button>
                    <button class="memory-filter-btn" data-type="nickname">稱呼</button>
                    <button class="memory-filter-btn" data-type="milestone">里程碑</button>
                    <button class="memory-filter-btn" data-type="dislike">禁忌</button>
                </div>
            </div>
            
            <!-- 記憶時間軸 -->
            <div class="bg-white border rounded-lg p-6">
                <h2 class="text-xl font-semibold mb-4">
                    <i class="fas fa-timeline text-green-400 mr-2"></i>
                    記憶時間軸
                </h2>
                
                <div id="memoryTimeline" class="space-y-4">
                    <!-- 動態生成記憶時間軸 -->
                </div>
                
                <!-- 載入更多 -->
                <div class="text-center mt-6">
                    <button 
                        id="loadMoreMemoriesBtn"
                        class="bg-gray-600 hover:bg-gray-700 text-white px-6 py-2 rounded"
                        onclick="loadMoreMemories()"
                    >
                        載入更多記憶
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 右側 - 記憶統計和管理 -->
        <div class="space-y-6">
            <!-- 記憶統計 -->
            <div class="bg-white border rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">
                    <i class="fas fa-chart-bar text-blue-400 mr-2"></i>
                    記憶統計
                </h3>
                
                <div class="space-y-4">
                    <div class="text-center">
                        <div class="text-3xl font-bold text-purple-400" id="totalMemories">0</div>
                        <div class="text-sm text-gray-600">總記憶數</div>
                    </div>
                    
                    <div class="text-center">
                        <div class="text-3xl font-bold text-green-400" id="importantMemories">0</div>
                        <div class="text-sm text-gray-600">重要記憶</div>
                    </div>
                    
                    <div class="text-center">
                        <div class="text-3xl font-bold text-blue-400" id="recentMemories">0</div>
                        <div class="text-sm text-gray-600">最近新增</div>
                    </div>
                </div>
            </div>
            
            <!-- 記憶類型分布 -->
            <div class="bg-white border rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">
                    <i class="fas fa-pie-chart text-yellow-400 mr-2"></i>
                    記憶分布
                </h3>
                
                <div class="space-y-3" id="memoryDistribution">
                    <!-- 動態生成記憶分布 -->
                </div>
            </div>
            
            <!-- 記憶管理 -->
            <div class="bg-white border rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">
                    <i class="fas fa-cogs text-gray-400 mr-2"></i>
                    記憶管理
                </h3>
                
                <div class="space-y-3">
                    <button 
                        class="w-full bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded text-left"
                        onclick="backupMemory()"
                    >
                        <i class="fas fa-cloud-upload mr-2"></i>
                        備份記憶
                    </button>
                    
                    <button 
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded text-left"
                        onclick="showRestoreModal()"
                    >
                        <i class="fas fa-cloud-download mr-2"></i>
                        還原記憶
                    </button>
                    
                    <button 
                        class="w-full bg-yellow-600 hover:bg-yellow-700 text-white py-2 px-4 rounded text-left"
                        onclick="organizeMemories()"
                    >
                        <i class="fas fa-magic mr-2"></i>
                        整理記憶
                    </button>
                    
                    <button 
                        class="w-full bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded text-left"
                        onclick="clearMemories()"
                    >
                        <i class="fas fa-trash mr-2"></i>
                        清理記憶
                    </button>
                </div>
            </div>
            
            <!-- 記憶深度 -->
            <div class="bg-white border rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">
                    <i class="fas fa-layer-group text-indigo-400 mr-2"></i>
                    記憶深度
                </h3>
                
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span class="text-sm">表層記憶</span>
                        <div class="flex-1 mx-3 bg-gray-200 rounded-full h-2">
                            <div class="bg-blue-400 h-2 rounded-full" style="width: 60%"></div>
                        </div>
                        <span class="text-sm text-gray-600">60%</span>
                    </div>
                    
                    <div class="flex justify-between items-center">
                        <span class="text-sm">深度記憶</span>
                        <div class="flex-1 mx-3 bg-gray-200 rounded-full h-2">
                            <div class="bg-purple-400 h-2 rounded-full" style="width: 35%"></div>
                        </div>
                        <span class="text-sm text-gray-600">35%</span>
                    </div>
                    
                    <div class="flex justify-between items-center">
                        <span class="text-sm">核心記憶</span>
                        <div class="flex-1 mx-3 bg-gray-200 rounded-full h-2">
                            <div class="bg-red-400 h-2 rounded-full" style="width: 5%"></div>
                        </div>
                        <span class="text-sm text-gray-600">5%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 記憶詳情模態框 -->
    <div id="memoryDetailModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white border rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-start mb-4">
                <h3 class="text-2xl font-bold">
                    <i class="fas fa-brain text-purple-400 mr-2"></i>
                    記憶詳情
                </h3>
                <button 
                    class="text-gray-400 hover:text-gray-600"
                    onclick="closeMemoryDetailModal()"
                >
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            
            <div id="memoryDetailContent">
                <!-- 動態填充記憶詳情 -->
            </div>
            
            <div class="flex justify-end space-x-4 mt-6">
                <button 
                    class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded"
                    onclick="deleteMemory()"
                >
                    <i class="fas fa-trash mr-2"></i>
                    刪除記憶
                </button>
                <button 
                    class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded"
                    onclick="closeMemoryDetailModal()"
                >
                    關閉
                </button>
            </div>
        </div>
    </div>
    
    <!-- 還原記憶模態框 -->
    <div id="restoreModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white border rounded-lg p-6 max-w-md w-full mx-4">
            <h3 class="text-2xl font-bold mb-4">
                <i class="fas fa-cloud-download text-blue-400 mr-2"></i>
                還原記憶
            </h3>
            
            <div class="space-y-4">
                <div>
                    <label class="block font-medium mb-2">選擇備份檔案</label>
                    <input 
                        type="file" 
                        id="restoreFile"
                        class="w-full px-4 py-3 rounded bg-gray-100 border text-gray-900"
                        accept=".json"
                    >
                </div>
                
                <div class="bg-yellow-50 border border-yellow-200 rounded p-3 text-sm text-yellow-800">
                    <i class="fas fa-warning mr-2"></i>
                    還原記憶會覆蓋現有記憶，請謹慎操作
                </div>
                
                <div class="flex space-x-4">
                    <button 
                        class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-3 px-6 rounded font-semibold"
                        onclick="restoreMemory()"
                    >
                        <i class="fas fa-upload mr-2"></i>
                        開始還原
                    </button>
                    
                    <button 
                        class="bg-gray-600 hover:bg-gray-700 text-white py-3 px-6 rounded font-semibold"
                        onclick="closeRestoreModal()"
                    >
                        取消
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- CSS -->
    <style>
        .memory-filter-btn {
            @apply px-3 py-1 rounded-full text-sm border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 transition-colors;
        }
        .memory-filter-btn.active {
            @apply bg-blue-600 text-white border-blue-600;
        }
        .memory-item {
            @apply border-l-4 pl-4 py-3 hover:bg-gray-50 transition-colors cursor-pointer;
        }
        .memory-item.preference {
            @apply border-l-blue-400;
        }
        .memory-item.nickname {
            @apply border-l-green-400;
        }
        .memory-item.milestone {
            @apply border-l-yellow-400;
        }
        .memory-item.dislike {
            @apply border-l-red-400;
        }
    </style>
    
    <!-- JavaScript -->
    <script src="/public/assets/common.js"></script>
    <script>
        let memoryData = [];
        let currentFilter = 'all';
        let currentPage = 1;
        let selectedMemoryId = null;
        
        // 頁面初始化
        document.addEventListener('DOMContentLoaded', async function() {
            await App.init();
            
            // 載入記憶數據
            await loadMemoryData();
            
            // 設置事件監聽器
            setupEventListeners();
        });
        
        // 設置事件監聽器
        function setupEventListeners() {
            // 記憶類型篩選
            document.querySelectorAll('.memory-filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // 更新活動狀態
                    document.querySelectorAll('.memory-filter-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // 更新篩選條件
                    currentFilter = this.dataset.type;
                    filterMemories();
                });
            });
        }
        
        // 載入記憶數據
        async function loadMemoryData() {
            try {
                // 載入記憶時間軸
                const params = new URLSearchParams({
                    page: currentPage.toString(),
                    limit: '20'
                });
                const timelineResult = await ApiClient.get(`/api/v1/memory/timeline?${params.toString()}`);
                
                if (timelineResult.success && timelineResult.data) {
                    memoryData = timelineResult.data.memories || [];
                    displayMemoryTimeline(memoryData);
                } else {
                    throw new Error('載入記憶時間軸失敗');
                }
                
                // 載入記憶統計
                await loadMemoryStats();
                
            } catch (error) {
                console.error('載入記憶數據失敗:', error);
                
                // 顯示錯誤狀態
                memoryData = [];
                displayMemoryTimeline(memoryData);
                updateMemoryStats({
                    total_memories: 0,
                    important_memories: 0,
                    recent_memories: 0,
                    type_distribution: {}
                });
                
                UI.showToast('載入記憶數據失敗', 'error');
            }
        }
        
        // 顯示記憶時間軸
        function displayMemoryTimeline(memories) {
            const timeline = document.getElementById('memoryTimeline');
            timeline.innerHTML = '';
            
            memories.forEach(memory => {
                const item = createMemoryTimelineItem(memory);
                timeline.appendChild(item);
            });
        }
        
        // 創建記憶時間軸項目
        function createMemoryTimelineItem(memory) {
            const item = document.createElement('div');
            item.className = `memory-item ${memory.type}`;
            item.onclick = () => showMemoryDetail(memory);
            
            const timeStr = memory.created_at ? Utils.formatDateTime(memory.created_at) : '未知時間';
            const importance = memory.importance || 0;
            
            // 根據重要度設置圖標
            let iconClass = 'fas fa-circle';
            let iconColor = 'text-gray-400';
            if (importance >= 8) {
                iconClass = 'fas fa-star';
                iconColor = 'text-yellow-500';
            } else if (importance >= 6) {
                iconClass = 'fas fa-heart';
                iconColor = 'text-red-500';
            } else if (importance >= 4) {
                iconClass = 'fas fa-bookmark';
                iconColor = 'text-blue-500';
            }
            
            item.innerHTML = `
                <div class="flex items-start space-x-3">
                    <div class="flex-shrink-0 mt-1">
                        <i class="${iconClass} ${iconColor}"></i>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-start mb-1">
                            <span class="font-medium text-sm">${getMemoryTypeLabel(memory.type)}</span>
                            <span class="text-xs text-gray-500">${timeStr}</span>
                        </div>
                        <div class="text-gray-700 text-sm mb-2">${memory.content || '無內容'}</div>
                        <div class="flex items-center space-x-4 text-xs text-gray-500">
                            <span>重要度: ${importance}/10</span>
                            <span>角色: ${memory.character_name || '未知'}</span>
                            ${memory.trigger ? `<span>觸發: ${memory.trigger}</span>` : ''}
                        </div>
                    </div>
                </div>
            `;
            
            return item;
        }
        
        // 獲取記憶類型標籤
        function getMemoryTypeLabel(type) {
            const labels = {
                'preference': '偏好記憶',
                'nickname': '稱呼記憶', 
                'milestone': '里程碑',
                'dislike': '禁忌記憶',
                'conversation': '對話記憶',
                'emotion': '情感記憶'
            };
            return labels[type] || type;
        }
        
        // 載入記憶統計
        async function loadMemoryStats() {
            try {
                const statsResult = await ApiClient.get('/api/v1/memory/stats');
                
                if (statsResult.success && statsResult.data) {
                    updateMemoryStats(statsResult.data);
                } else {
                    throw new Error('載入記憶統計失敗');
                }
                
            } catch (error) {
                console.warn('載入記憶統計失敗:', error);
                updateMemoryStats({
                    total_memories: 0,
                    important_memories: 0,
                    recent_memories: 0,
                    type_distribution: {}
                });
            }
        }
        
        // 更新記憶統計
        function updateMemoryStats(stats) {
            document.getElementById('totalMemories').textContent = stats.total_memories || 0;
            document.getElementById('importantMemories').textContent = stats.important_memories || 0;
            document.getElementById('recentMemories').textContent = stats.recent_memories || 0;
            
            // 更新記憶分布
            updateMemoryDistribution(stats.type_distribution || {});
        }
        
        // 更新記憶分布
        function updateMemoryDistribution(distribution) {
            const container = document.getElementById('memoryDistribution');
            container.innerHTML = '';
            
            const types = [
                { key: 'preference', label: '偏好', color: 'blue' },
                { key: 'nickname', label: '稱呼', color: 'green' },
                { key: 'milestone', label: '里程碑', color: 'yellow' },
                { key: 'dislike', label: '禁忌', color: 'red' }
            ];
            
            const total = Object.values(distribution).reduce((sum, count) => sum + count, 0);
            
            types.forEach(type => {
                const count = distribution[type.key] || 0;
                const percentage = total > 0 ? Math.round(count / total * 100) : 0;
                
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center';
                item.innerHTML = `
                    <span class="text-sm">${type.label}</span>
                    <div class="flex-1 mx-3 bg-gray-200 rounded-full h-2">
                        <div class="bg-${type.color}-400 h-2 rounded-full" style="width: ${percentage}%"></div>
                    </div>
                    <span class="text-sm text-gray-600">${count}</span>
                `;
                
                container.appendChild(item);
            });
        }
        
        // 處理記憶搜尋按鍵
        function handleMemorySearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchMemory();
            }
        }
        
        // 搜尋記憶
        async function searchMemory() {
            const query = document.getElementById('memorySearchQuery').value.trim();
            if (!query) {
                UI.showToast('請輸入搜尋關鍵字', 'warning');
                return;
            }
            
            try {
                UI.showGlobalLoading(true);
                
                const params = new URLSearchParams({
                    query: query,
                    page: '1',
                    limit: '50'
                });
                if (currentFilter !== 'all') {
                    params.append('type', currentFilter);
                }
                const result = await ApiClient.get(`/api/v1/memory/search?${params.toString()}`);
                
                if (result.success && result.data) {
                    memoryData = result.data.memories || [];
                    displayMemoryTimeline(memoryData);
                    UI.showToast(`找到 ${memoryData.length} 個相關記憶`, 'success');
                } else {
                    throw new Error(result.error?.message || '搜尋失敗');
                }
                
            } catch (error) {
                console.error('搜尋記憶失敗:', error);
                
                // 使用本地搜尋
                const filteredMemories = memoryData.filter(memory => 
                    memory.content && memory.content.toLowerCase().includes(query.toLowerCase())
                );
                displayMemoryTimeline(filteredMemories);
                UI.showToast(`本地搜尋找到 ${filteredMemories.length} 個結果`, 'info');
                
            } finally {
                UI.showGlobalLoading(false);
            }
        }
        
        // 篩選記憶
        function filterMemories() {
            let filteredMemories = memoryData;
            
            if (currentFilter !== 'all') {
                filteredMemories = memoryData.filter(memory => memory.type === currentFilter);
            }
            
            displayMemoryTimeline(filteredMemories);
        }
        
        // 顯示記憶詳情
        function showMemoryDetail(memory) {
            selectedMemoryId = memory.id;
            
            const content = document.getElementById('memoryDetailContent');
            const timeStr = memory.created_at ? Utils.formatDateTime(memory.created_at) : '未知時間';
            
            content.innerHTML = `
                <div class="space-y-4">
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700">記憶類型</label>
                            <div class="mt-1 text-sm text-gray-900">${getMemoryTypeLabel(memory.type)}</div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">重要度</label>
                            <div class="mt-1 text-sm text-gray-900">${memory.importance || 0}/10</div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">角色</label>
                            <div class="mt-1 text-sm text-gray-900">${memory.character_name || '未知'}</div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">建立時間</label>
                            <div class="mt-1 text-sm text-gray-900">${timeStr}</div>
                        </div>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700">記憶內容</label>
                        <div class="mt-1 p-3 bg-gray-50 rounded border text-sm text-gray-900">
                            ${memory.content || '無內容'}
                        </div>
                    </div>
                    
                    ${memory.trigger ? `
                        <div>
                            <label class="block text-sm font-medium text-gray-700">觸發條件</label>
                            <div class="mt-1 text-sm text-gray-900">${memory.trigger}</div>
                        </div>
                    ` : ''}
                    
                    ${memory.context ? `
                        <div>
                            <label class="block text-sm font-medium text-gray-700">上下文</label>
                            <div class="mt-1 p-3 bg-gray-50 rounded border text-sm text-gray-900">
                                ${memory.context}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            document.getElementById('memoryDetailModal').classList.remove('hidden');
        }
        
        // 關閉記憶詳情模態框
        function closeMemoryDetailModal() {
            document.getElementById('memoryDetailModal').classList.add('hidden');
            selectedMemoryId = null;
        }
        
        // 備份記憶
        async function backupMemory() {
            try {
                UI.showGlobalLoading(true);
                
                const result = await ApiClient.post('/api/v1/memory/backup');
                
                if (result.success && result.data) {
                    // 下載備份檔案
                    const blob = new Blob([JSON.stringify(result.data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `memory_backup_${moment().format('YYYY-MM-DD')}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    UI.showToast('記憶備份成功', 'success');
                } else {
                    throw new Error(result.error?.message || '備份失敗');
                }
                
            } catch (error) {
                console.error('備份記憶失敗:', error);
                
                UI.showToast('備份失敗: ' + error.message, 'error');
                
            } finally {
                UI.showGlobalLoading(false);
            }
        }
        
        // 顯示還原模態框
        function showRestoreModal() {
            document.getElementById('restoreModal').classList.remove('hidden');
        }
        
        // 關閉還原模態框
        function closeRestoreModal() {
            document.getElementById('restoreModal').classList.add('hidden');
        }
        
        // 還原記憶
        async function restoreMemory() {
            const fileInput = document.getElementById('restoreFile');
            const file = fileInput.files[0];
            
            if (!file) {
                UI.showToast('請選擇備份檔案', 'warning');
                return;
            }
            
            try {
                UI.showGlobalLoading(true);
                
                const text = await file.text();
                const backupData = JSON.parse(text);
                
                // 驗證備份檔案格式
                if (!backupData.memories || !Array.isArray(backupData.memories)) {
                    throw new Error('無效的備份檔案格式');
                }
                
                const result = await ApiClient.post('/api/v1/memory/restore', backupData);
                
                if (result.success) {
                    UI.showToast('記憶還原成功', 'success');
                    closeRestoreModal();
                    
                    // 重新載入記憶數據
                    await loadMemoryData();
                } else {
                    throw new Error(result.error?.message || '還原失敗');
                }
                
            } catch (error) {
                console.error('還原記憶失敗:', error);
                UI.showToast('還原失敗: ' + error.message, 'error');
            } finally {
                UI.showGlobalLoading(false);
            }
        }
        
        // 整理記憶
        async function organizeMemories() {
            if (!confirm('確定要整理記憶嗎？這可能會改變記憶的重要度排序。')) {
                return;
            }
            
            try {
                UI.showGlobalLoading(true);
                
                // 實際整理記憶的 API 調用
                const result = await ApiClient.post('/api/v1/memory/organize');
                
                if (result.success) {
                    UI.showToast('記憶整理完成', 'success');
                    await loadMemoryData();
                } else {
                    throw new Error(result.error?.message || '整理失敗');
                }
                
            } catch (error) {
                console.error('整理記憶失敗:', error);
                UI.showToast('整理失敗: ' + error.message, 'error');
            } finally {
                UI.showGlobalLoading(false);
            }
        }
        
        // 清理記憶
        async function clearMemories() {
            if (!confirm('確定要清理低重要度的記憶嗎？此操作無法撤銷。')) {
                return;
            }
            
            try {
                UI.showGlobalLoading(true);
                
                // 實際清理記憶的 API 調用
                const result = await ApiClient.post('/api/v1/memory/cleanup', {
                    min_importance: 3
                });
                
                if (result.success) {
                    UI.showToast('低重要度記憶已清理', 'success');
                    await loadMemoryData();
                } else {
                    throw new Error(result.error?.message || '清理失敗');
                }
                
            } catch (error) {
                console.error('清理記憶失敗:', error);
                UI.showToast('清理失敗: ' + error.message, 'error');
            } finally {
                UI.showGlobalLoading(false);
            }
        }
        
        // 刷新記憶數據
        async function refreshMemoryData() {
            currentPage = 1;
            await loadMemoryData();
            UI.showToast('記憶數據已刷新', 'success');
        }
        
        // 載入更多記憶
        async function loadMoreMemories() {
            currentPage++;
            try {
                const params = new URLSearchParams({
                    page: currentPage.toString(),
                    limit: '20'
                });
                const result = await ApiClient.get(`/api/v1/memory/timeline?${params.toString()}`);
                
                if (result.success && result.data && result.data.memories) {
                    const newMemories = result.data.memories;
                    memoryData.push(...newMemories);
                    
                    // 添加新記憶到時間軸
                    const timeline = document.getElementById('memoryTimeline');
                    newMemories.forEach(memory => {
                        const item = createMemoryTimelineItem(memory);
                        timeline.appendChild(item);
                    });
                    
                    if (newMemories.length === 0) {
                        document.getElementById('loadMoreMemoriesBtn').style.display = 'none';
                    }
                } else {
                    document.getElementById('loadMoreMemoriesBtn').style.display = 'none';
                }
            } catch (error) {
                console.error('載入更多記憶失敗:', error);
                UI.showToast('載入失敗', 'error');
            }
        }
        
        // 刪除記憶
        async function deleteMemory() {
            if (!selectedMemoryId) return;
            
            if (!confirm('確定要刪除這個記憶嗎？此操作無法撤銷。')) {
                return;
            }
            
            try {
                const result = await ApiClient.delete('/api/v1/memory/forget', {
                    memory_id: selectedMemoryId
                });
                
                if (result.success) {
                    UI.showToast('記憶已刪除', 'success');
                    closeMemoryDetailModal();
                    
                    // 從本地數據中移除
                    memoryData = memoryData.filter(memory => memory.id !== selectedMemoryId);
                    displayMemoryTimeline(memoryData);
                    await loadMemoryStats();
                } else {
                    throw new Error(result.error?.message || '刪除失敗');
                }
                
            } catch (error) {
                console.error('刪除記憶失敗:', error);
                
                UI.showToast('刪除失敗: ' + error.message, 'error');
            }
        }
        
        
        // 返回上一頁
        function goBack() {
            Router.navigate('/');
        }
    </script>
</body>
</html>